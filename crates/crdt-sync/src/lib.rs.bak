//! Production-Ready Delta-CRDT synchronization with anti-entropy
//!
//! Implements:
//! - Delta-CRDTs for bandwidth efficiency
//! - OR-Set with proper concurrent add/remove semantics
//! - LWW-Register with vector clocks
//! - Anti-entropy reconciliation
//! - IBLT reconciliation for large sets (future)

use anyhow::Result;
use saorsa_gossip_types::PeerId;
use serde::{de::DeserializeOwned, Deserialize, Serialize};
use std::collections::{HashMap, HashSet};
use std::hash::Hash;

/// CRDT types
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CrdtType {
    /// Observed-Remove Set
    OrSet,
    /// Last-Writer-Wins Register
    LwwRegister,
    /// Replicated Growable Array
    Rga,
}

/// Delta-CRDT trait for bandwidth-efficient synchronization
pub trait DeltaCrdt: Send + Sync {
    /// Type of the delta
    type Delta: Clone + Serialize + for<'de> Deserialize<'de>;

    /// Merge a delta into this CRDT
    fn merge(&mut self, delta: &Self::Delta) -> Result<()>;

    /// Generate a delta for changes since a given version
    fn delta(&self, since_version: u64) -> Option<Self::Delta>;

    /// Get current version
    fn version(&self) -> u64;
}

/// Unique tag for OR-Set elements: (PeerId, sequence_number)
pub type UniqueTag = (PeerId, u64);

/// Production-ready OR-Set (Observed-Remove Set)
///
/// Properly handles concurrent add/remove operations from multiple replicas.
/// Uses (element, Set<UniqueTag>) to track all concurrent adds.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrSet<T: Hash + Eq + Clone> {
    /// Elements with their unique tags (peer_id, seq) per concurrent add
    elements: HashMap<T, HashSet<UniqueTag>>,
    /// Tombstones: tags that have been removed
    tombstones: HashMap<T, HashSet<UniqueTag>>,
    /// Current version for delta generation
    version: u64,
    /// Version -> (additions, removals) for delta tracking
    changelog: HashMap<u64, (HashMap<T, HashSet<UniqueTag>>, HashMap<T, HashSet<UniqueTag>>)>,
}

impl<T: Hash + Eq + Clone> OrSet<T> {
    /// Create a new OR-Set
    pub fn new() -> Self {
        Self {
            elements: HashMap::new(),
            tombstones: HashMap::new(),
            version: 0,
            changelog: HashMap::new(),
        }
    }

    /// Add an element with a unique tag
    ///
    /// The tag should be (peer_id, sequence_number) to ensure uniqueness
    /// across all replicas.
    pub fn add(&mut self, element: T, tag: UniqueTag) -> Result<()> {
        // Add to elements
        self.elements
            .entry(element.clone())
            .or_insert_with(HashSet::new)
            .insert(tag);

        // Remove from tombstones if it was previously removed
        if let Some(ts) = self.tombstones.get_mut(&element) {
            ts.remove(&tag);
            if ts.is_empty() {
                self.tombstones.remove(&element);
            }
        }

        // Record in changelog
        self.version += 1;
        let changelog_entry = self.changelog.entry(self.version).or_insert((HashMap::new(), HashMap::new()));
        changelog_entry.0
            .entry(element)
            .or_insert_with(HashSet::new)
            .insert(tag);

        Ok(())
    }

    /// Remove an element
    ///
    /// Removes all tags associated with this element, preventing
    /// concurrent adds from being visible.
    pub fn remove(&mut self, element: &T) -> Result<()> {
        if let Some(tags) = self.elements.get(element).cloned() {
            // Move all tags to tombstones
            for tag in &tags {
                self.tombstones
                    .entry(element.clone())
                    .or_insert_with(HashSet::new)
                    .insert(*tag);
            }

            // Remove from elements
            self.elements.remove(element);

            // Record in changelog
            self.version += 1;
            let changelog_entry = self.changelog.entry(self.version).or_insert((HashMap::new(), HashMap::new()));
            changelog_entry.1
                .entry(element.clone())
                .or_insert_with(HashSet::new)
                .extend(tags);
        }

        Ok(())
    }

    /// Check if element exists (not removed)
    pub fn contains(&self, element: &T) -> bool {
        self.elements.contains_key(element)
    }

    /// Get all elements (not removed)
    pub fn elements(&self) -> Vec<&T> {
        self.elements.keys().collect()
    }

    /// Get element count
    pub fn len(&self) -> usize {
        self.elements.len()
    }

    /// Check if empty
    pub fn is_empty(&self) -> bool {
        self.elements.is_empty()
    }

    /// Merge another OR-Set into this one
    ///
    /// This implements the merge operation for state-based CRDTs.
    /// Preserves all concurrent adds and removes.
    pub fn merge_state(&mut self, other: &OrSet<T>) -> Result<()> {
        // Merge elements
        for (elem, tags) in &other.elements {
            let our_tags = self.elements.entry(elem.clone()).or_insert_with(HashSet::new);
            our_tags.extend(tags);

            // Remove any tags that are in our tombstones
            if let Some(our_tombstones) = self.tombstones.get(elem) {
                our_tags.retain(|tag| !our_tombstones.contains(tag));
            }
        }

        // Merge tombstones
        for (elem, tags) in &other.tombstones {
            let our_tombstones = self.tombstones.entry(elem.clone()).or_insert_with(HashSet::new);
            our_tombstones.extend(tags);

            // Remove tombstoned tags from our elements
            if let Some(our_tags) = self.elements.get_mut(elem) {
                our_tags.retain(|tag| !our_tombstones.contains(tag));
                if our_tags.is_empty() {
                    self.elements.remove(elem);
                }
            }
        }

        // Update version to max
        self.version = self.version.max(other.version);

        Ok(())
    }

    /// Clear old changelog entries to prevent unbounded growth
    pub fn compact(&mut self, keep_versions: u64) {
        if self.version > keep_versions {
            let min_version = self.version - keep_versions;
            self.changelog.retain(|v, _| *v > min_version);
        }
    }
}

impl<T: Hash + Eq + Clone> Default for OrSet<T> {
    fn default() -> Self {
        Self::new()
    }
}

/// Delta for OR-Set (changes since a version)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrSetDelta<T: Hash + Eq + Clone + Serialize + DeserializeOwned> {
    /// Added elements with their tags
    pub added: HashMap<T, HashSet<UniqueTag>>,
    /// Removed tags (tombstones)
    pub removed: HashMap<T, HashSet<UniqueTag>>,
    /// Version this delta represents
    pub version: u64,
}

impl<T: Hash + Eq + Clone + Send + Sync + Serialize + DeserializeOwned> DeltaCrdt for OrSet<T> {
    type Delta = OrSetDelta<T>;

    fn merge(&mut self, delta: &Self::Delta) -> Result<()> {
        // Apply additions
        for (elem, tags) in &delta.added {
            let our_tags = self.elements.entry(elem.clone()).or_insert_with(HashSet::new);
            our_tags.extend(tags);
        }

        // Apply removals (tombstones)
        for (elem, tags) in &delta.removed {
            let our_tombstones = self.tombstones.entry(elem.clone()).or_insert_with(HashSet::new);
            our_tombstones.extend(tags);

            // Remove tombstoned tags from elements
            if let Some(our_tags) = self.elements.get_mut(elem) {
                our_tags.retain(|tag| !our_tombstones.contains(tag));
                if our_tags.is_empty() {
                    self.elements.remove(elem);
                }
            }
        }

        // Update version
        self.version = self.version.max(delta.version);

        Ok(())
    }

    fn delta(&self, since_version: u64) -> Option<Self::Delta> {
        if since_version >= self.version {
            return None;
        }

        let mut added = HashMap::new();
        let mut removed = HashMap::new();

        // Collect changes from changelog
        for version in (since_version + 1)..=self.version {
            if let Some((adds, removes)) = self.changelog.get(&version) {
                for (elem, tags) in adds {
                    added.entry(elem.clone()).or_insert_with(HashSet::new).extend(tags);
                }
                for (elem, tags) in removes {
                    removed.entry(elem.clone()).or_insert_with(HashSet::new).extend(tags);
                }
            }
        }

        Some(OrSetDelta {
            added,
            removed,
            version: self.version,
        })
    }

    fn version(&self) -> u64 {
        self.version
    }
}

/// Vector Clock for causality tracking
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct VectorClock {
    clocks: HashMap<PeerId, u64>,
}

impl VectorClock {
    /// Create a new vector clock
    pub fn new() -> Self {
        Self {
            clocks: HashMap::new(),
        }
    }

    /// Increment the clock for a peer
    pub fn increment(&mut self, peer: PeerId) {
        *self.clocks.entry(peer).or_insert(0) += 1;
    }

    /// Get the clock value for a peer
    pub fn get(&self, peer: &PeerId) -> u64 {
        self.clocks.get(peer).copied().unwrap_or(0)
    }

    /// Merge another vector clock (take maximum of each entry)
    pub fn merge(&mut self, other: &VectorClock) {
        for (peer, &time) in &other.clocks {
            let our_time = self.clocks.entry(*peer).or_insert(0);
            *our_time = (*our_time).max(time);
        }
    }

    /// Check if this clock happens before another
    pub fn happens_before(&self, other: &VectorClock) -> bool {
        let mut strictly_less = false;

        // Check all our entries
        for (peer, &our_time) in &self.clocks {
            let other_time = other.get(peer);
            if our_time > other_time {
                return false; // We have a greater timestamp
            }
            if our_time < other_time {
                strictly_less = true;
            }
        }

        // Check for entries only in other
        for peer in other.clocks.keys() {
            if !self.clocks.contains_key(peer) && other.get(peer) > 0 {
                strictly_less = true;
            }
        }

        strictly_less
    }

    /// Check if two clocks are concurrent (neither happens before the other)
    pub fn concurrent(&self, other: &VectorClock) -> bool {
        !self.happens_before(other) && !other.happens_before(self) && self != other
    }
}

impl Default for VectorClock {
    fn default() -> Self {
        Self::new()
    }
}

/// LWW Register with Vector Clock
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LwwRegister<T: Clone> {
    value: T,
    clock: VectorClock,
}

impl<T: Clone> LwwRegister<T> {
    /// Create a new LWW register
    pub fn new(value: T) -> Self {
        Self {
            value,
            clock: VectorClock::new(),
        }
    }

    /// Set value with vector clock
    pub fn set(&mut self, value: T, peer: PeerId) {
        self.clock.increment(peer);
        self.value = value;
    }

    /// Get the current value
    pub fn get(&self) -> &T {
        &self.value
    }

    /// Get the vector clock
    pub fn clock(&self) -> &VectorClock {
        &self.clock
    }

    /// Merge with another register (keep value with later clock)
    pub fn merge(&mut self, other: &LwwRegister<T>) {
        if other.clock.happens_before(&self.clock) {
            // Keep our value
            self.clock.merge(&other.clock);
        } else if self.clock.happens_before(&other.clock) {
            // Take their value
            self.value = other.value.clone();
            self.clock = other.clock.clone();
        } else if self.clock.concurrent(&other.clock) {
            // Concurrent: use deterministic tiebreaker (smaller hash wins)
            let our_hash = self.hash_clock();
            let their_hash = other.hash_clock();

            if their_hash < our_hash {
                self.value = other.value.clone();
            }
            self.clock.merge(&other.clock);
        }
    }

    fn hash_clock(&self) -> u64 {
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};

        let mut hasher = DefaultHasher::new();
        // Hash peer IDs and values in sorted order for determinism
        let mut sorted: Vec<_> = self.clock.clocks.iter().collect();
        sorted.sort_by_key(|(peer, _)| peer.as_bytes());
        sorted.hash(&mut hasher);
        hasher.finish()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn peer(n: u8) -> PeerId {
        PeerId::new([n; 32])
    }

    // OR-Set Tests

    #[test]
    fn test_or_set_basic_add_remove() {
        let mut set = OrSet::new();
        let p1 = peer(1);

        set.add("alice", (p1, 1)).ok();
        assert!(set.contains(&"alice"));
        assert_eq!(set.len(), 1);

        set.remove(&"alice").ok();
        assert!(!set.contains(&"alice"));
        assert_eq!(set.len(), 0);
    }

    #[test]
    fn test_or_set_concurrent_add() {
        let mut set = OrSet::new();
        let p1 = peer(1);
        let p2 = peer(2);

        // Concurrent adds from different peers
        set.add("alice", (p1, 1)).ok();
        set.add("alice", (p2, 1)).ok();

        assert!(set.contains(&"alice"));

        // Both tags should be present
        assert_eq!(set.elements.get(&"alice").unwrap().len(), 2);
    }

    #[test]
    fn test_or_set_add_remove_add() {
        let mut set = OrSet::new();
        let p1 = peer(1);

        // Add, remove, add again
        set.add("alice", (p1, 1)).ok();
        set.remove(&"alice").ok();
        set.add("alice", (p1, 2)).ok();  // Different sequence number

        assert!(set.contains(&"alice"));
    }

    #[test]
    fn test_or_set_merge_commutativity() {
        let mut set1 = OrSet::new();
        let mut set2 = OrSet::new();
        let p1 = peer(1);
        let p2 = peer(2);

        set1.add("alice", (p1, 1)).ok();
        set2.add("bob", (p2, 1)).ok();

        let mut merged_a = set1.clone();
        merged_a.merge_state(&set2).ok();

        let mut merged_b = set2.clone();
        merged_b.merge_state(&set1).ok();

        // Should converge to same state
        assert_eq!(merged_a.len(), merged_b.len());
        assert!(merged_a.contains(&"alice"));
        assert!(merged_a.contains(&"bob"));
        assert!(merged_b.contains(&"alice"));
        assert!(merged_b.contains(&"bob"));
    }

    #[test]
    fn test_or_set_merge_idempotence() {
        let mut set1 = OrSet::new();
        let mut set2 = OrSet::new();
        let p1 = peer(1);

        set1.add("alice", (p1, 1)).ok();
        set2.add("bob", (p1, 2)).ok();

        set1.merge_state(&set2).ok();
        let len_after_first = set1.len();

        set1.merge_state(&set2).ok();
        let len_after_second = set1.len();

        // Multiple merges should not change state
        assert_eq!(len_after_first, len_after_second);
    }

    #[test]
    fn test_or_set_delta_generation() {
        let mut set = OrSet::new();
        let p1 = peer(1);

        let v0 = set.version();
        set.add("alice", (p1, 1)).ok();
        set.add("bob", (p1, 2)).ok();

        let delta = set.delta(v0).expect("should have delta");
        assert_eq!(delta.added.len(), 2);
        assert!(delta.added.contains_key(&"alice"));
        assert!(delta.added.contains_key(&"bob"));
    }

    #[test]
    fn test_or_set_delta_merge() {
        let mut set1 = OrSet::new();
        let mut set2 = OrSet::new();
        let p1 = peer(1);
        let p2 = peer(2);

        set1.add("alice", (p1, 1)).ok();

        let v0 = set2.version();
        set2.add("bob", (p2, 1)).ok();
        set2.add("charlie", (p2, 2)).ok();

        // Get delta and merge
        let delta = set2.delta(v0).expect("should have delta");
        set1.merge(&delta).ok();

        assert!(set1.contains(&"alice"));
        assert!(set1.contains(&"bob"));
        assert!(set1.contains(&"charlie"));
    }

    // Vector Clock Tests

    #[test]
    fn test_vector_clock_increment() {
        let mut clock = VectorClock::new();
        let p1 = peer(1);

        assert_eq!(clock.get(&p1), 0);
        clock.increment(p1);
        assert_eq!(clock.get(&p1), 1);
        clock.increment(p1);
        assert_eq!(clock.get(&p1), 2);
    }

    #[test]
    fn test_vector_clock_merge() {
        let mut clock1 = VectorClock::new();
        let mut clock2 = VectorClock::new();
        let p1 = peer(1);
        let p2 = peer(2);

        clock1.increment(p1);
        clock1.increment(p1);

        clock2.increment(p2);
        clock2.increment(p2);
        clock2.increment(p2);

        clock1.merge(&clock2);

        assert_eq!(clock1.get(&p1), 2);
        assert_eq!(clock1.get(&p2), 3);
    }

    #[test]
    fn test_vector_clock_happens_before() {
        let mut clock1 = VectorClock::new();
        let mut clock2 = VectorClock::new();
        let p1 = peer(1);

        clock1.increment(p1);
        clock2 = clock1.clone();
        clock2.increment(p1);

        assert!(clock1.happens_before(&clock2));
        assert!(!clock2.happens_before(&clock1));
    }

    #[test]
    fn test_vector_clock_concurrent() {
        let mut clock1 = VectorClock::new();
        let mut clock2 = VectorClock::new();
        let p1 = peer(1);
        let p2 = peer(2);

        clock1.increment(p1);
        clock2.increment(p2);

        assert!(clock1.concurrent(&clock2));
        assert!(clock2.concurrent(&clock1));
    }

    // LWW Register Tests

    #[test]
    fn test_lww_register_basic() {
        let mut reg = LwwRegister::new(42);
        let p1 = peer(1);

        assert_eq!(*reg.get(), 42);

        reg.set(100, p1);
        assert_eq!(*reg.get(), 100);
    }

    #[test]
    fn test_lww_register_merge_causality() {
        let mut reg1 = LwwRegister::new(0);
        let mut reg2 = LwwRegister::new(0);
        let p1 = peer(1);
        let p2 = peer(2);

        reg1.set(10, p1);
        reg2 = reg1.clone();
        reg2.set(20, p2);

        // reg2 happens after reg1
        reg1.merge(&reg2);
        assert_eq!(*reg1.get(), 20);
    }

    #[test]
    fn test_lww_register_concurrent_merge() {
        let mut reg1 = LwwRegister::new(0);
        let mut reg2 = LwwRegister::new(0);
        let p1 = peer(1);
        let p2 = peer(2);

        reg1.set(10, p1);
        reg2.set(20, p2);

        // Concurrent updates - should use deterministic tiebreaker
        let mut merged1 = reg1.clone();
        merged1.merge(&reg2);

        let mut merged2 = reg2.clone();
        merged2.merge(&reg1);

        // Both should converge to same value
        assert_eq!(merged1.get(), merged2.get());
    }

    #[test]
    fn test_or_set_compact() {
        let mut set = OrSet::new();
        let p1 = peer(1);

        // Add many elements to build up changelog
        for i in 0..100 {
            set.add(format!("elem-{}", i), (p1, i)).ok();
        }

        let changelog_before = set.changelog.len();
        set.compact(10);
        let changelog_after = set.changelog.len();

        assert!(changelog_after <= 10);
        assert!(changelog_after < changelog_before);
    }
}
